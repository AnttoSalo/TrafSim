<!DOCTYPE html>
<html lang="fi">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width,initial-scale=1" />
		<title>Top-down liikennesimulaatio (vapaamuotoiset tiet)</title>
		<style>
			:root {
				color-scheme: dark;
			}
			html,
			body {
				height: 100%;
				margin: 0;
				font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
				background: #0b0f14;
				color: #e7eef7;
			}
			#wrap {
				display: flex;
				height: 100%;
			}
			#ui {
				width: 340px;
				min-width: 340px;
				max-width: 340px;
				background: #0f1620;
				border-right: 1px solid #1a2533;
				padding: 12px;
				box-sizing: border-box;
				overflow: auto;
			}
			#canvasWrap {
				position: relative;
				flex: 1;
			}
			canvas {
				display: block;
				width: 100%;
				height: 100%;
			}
			h1 {
				font-size: 16px;
				margin: 0 0 10px;
				font-weight: 700;
				letter-spacing: 0.2px;
			}
			.card {
				background: #101c28;
				border: 1px solid #1a2a3a;
				border-radius: 14px;
				padding: 10px;
				margin: 10px 0;
			}
			.row {
				display: flex;
				gap: 8px;
				align-items: center;
				margin: 8px 0;
			}
			.row > label {
				flex: 1;
				font-size: 12px;
				color: #b7c7da;
			}
			input[type='range'] {
				width: 160px;
			}
			input[type='number'],
			input[type='text'],
			select {
				width: 120px;
				padding: 6px 8px;
				border-radius: 10px;
				border: 1px solid #223448;
				background: #0c1420;
				color: #e7eef7;
				outline: none;
			}
			button {
				appearance: none;
				border: 1px solid #223448;
				background: #0c1420;
				color: #e7eef7;
				padding: 8px 10px;
				border-radius: 12px;
				cursor: pointer;
			}
			button:hover {
				border-color: #2f4a67;
			}
			button.primary {
				background: #13263a;
				border-color: #244564;
			}
			button.danger {
				background: #2a1420;
				border-color: #6a2a44;
			}
			.pill {
				font-size: 11px;
				color: #b7c7da;
				padding: 2px 8px;
				border: 1px solid #223448;
				border-radius: 999px;
			}
			.mono {
				font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
			}
			#hud {
				position: absolute;
				left: 10px;
				top: 10px;
				background: rgba(10, 14, 18, 0.65);
				border: 1px solid rgba(255, 255, 255, 0.08);
				padding: 8px 10px;
				border-radius: 12px;
				backdrop-filter: blur(10px);
				font-size: 12px;
				color: #cfe2ff;
				pointer-events: none;
			}
			#help {
				position: absolute;
				right: 12px;
				bottom: 12px;
				background: rgba(10, 14, 18, 0.68);
				border: 1px solid rgba(255, 255, 255, 0.09);
				padding: 10px 12px;
				border-radius: 14px;
				backdrop-filter: blur(10px);
				font-size: 12px;
				color: #cfe2ff;
				max-width: 520px;
			}
			#help kbd {
				font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
				font-size: 11px;
				padding: 2px 6px;
				border-radius: 8px;
				border: 1px solid rgba(255, 255, 255, 0.18);
				background: rgba(255, 255, 255, 0.06);
			}
			.small {
				font-size: 12px;
				color: #b7c7da;
				line-height: 1.35;
			}
			.sep {
				height: 1px;
				background: #1a2533;
				margin: 10px 0;
			}
			.kv {
				display: flex;
				justify-content: space-between;
				gap: 10px;
				margin: 4px 0;
			}
			.kv span {
				color: #b7c7da;
				font-size: 12px;
			}
			.kv b {
				font-weight: 700;
				color: #e7eef7;
			}
		</style>
	</head>
	<body>
		<div id="wrap">
			<div id="ui">
				<h1>Liikennesimulaattori</h1>

				<div class="card">
					<div class="row">
						<label>Työkalu</label>
						<select id="tool">
							<option value="select">Valitse</option>
							<option value="draw">Piirrä tie</option>
							<option value="pan">Pan/Zoom</option>
						</select>
					</div>
					<div class="row">
						<button class="primary" id="btnPlay">▶ Käynnissä</button>
						<button id="btnStep">Step</button>
						<span class="pill" id="modePill">select</span>
					</div>
					<div class="row">
						<button id="btnClearCars">Tyhjennä autot</button>
						<button class="danger" id="btnClearMap">Tyhjennä kartta</button>
					</div>
					<div class="sep"></div>
					<div class="small">
						Piirrä tie: klikkaa pisteitä, <kbd>Enter</kbd> lopeta, <kbd>Esc</kbd> peruuta.<br />
						Valitse: klikkaa tietä. Vedä pisteitä (näkyy valitussa tiessä).<br />
						Pan: vedä hiirellä tai pidä <kbd>Space</kbd> pohjassa missä tahansa tilassa.
					</div>
				</div>

				<div class="card">
					<div class="row">
						<label>Spawn rate (autot/min)</label>
						<input type="range" id="spawnRate" min="0" max="600" value="120" />
						<input type="number" id="spawnRateN" min="0" max="600" value="120" />
					</div>
					<div class="row">
						<label>Maks. autot</label>
						<input type="range" id="maxCars" min="0" max="1200" value="500" />
						<input type="number" id="maxCarsN" min="0" max="5000" value="500" />
					</div>
					<div class="row">
						<label>V0 (m/s)</label>
						<input type="range" id="v0" min="2" max="40" value="16" />
						<input type="number" id="v0N" min="2" max="80" value="16" />
					</div>
					<div class="row">
						<label>Kiihtyvyys a (m/s²)</label>
						<input type="range" id="amax" min="0.5" max="5" step="0.1" value="1.8" />
						<input type="number" id="amaxN" min="0.1" max="10" step="0.1" value="1.8" />
					</div>
					<div class="row">
						<label>Jarru b (m/s²)</label>
						<input type="range" id="bmax" min="0.5" max="8" step="0.1" value="2.8" />
						<input type="number" id="bmaxN" min="0.1" max="15" step="0.1" value="2.8" />
					</div>
					<div class="row">
						<label>Headway T (s)</label>
						<input type="range" id="T" min="0.5" max="3.0" step="0.1" value="1.2" />
						<input type="number" id="TN" min="0.1" max="5" step="0.1" value="1.2" />
					</div>
					<div class="row">
						<label>Min gap s0 (m)</label>
						<input type="range" id="s0" min="1" max="10" step="0.5" value="2.0" />
						<input type="number" id="s0N" min="0" max="20" step="0.5" value="2.0" />
					</div>
					<div class="row">
						<label>δ (IDM)</label>
						<input type="range" id="delta" min="2" max="6" step="1" value="4" />
						<input type="number" id="deltaN" min="1" max="10" step="1" value="4" />
					</div>
					<div class="row">
						<label>Satunnaisuus (0–1)</label>
						<input type="range" id="noise" min="0" max="1" step="0.01" value="0.12" />
						<input type="number" id="noiseN" min="0" max="1" step="0.01" value="0.12" />
					</div>
				</div>

				<div class="card">
					<div class="row">
						<label>Valittu tie</label>
						<span class="pill mono" id="selInfo">—</span>
					</div>
					<div class="row">
						<label>Nopeusrajoitus (m/s)</label>
						<input type="number" id="roadSpeed" min="2" max="60" value="14" />
						<button id="btnApplyRoad">Aseta</button>
					</div>
					<div class="row">
						<label>2-suuntainen</label>
						<select id="roadTwoWay">
							<option value="true">Kyllä</option>
							<option value="false">Ei (1-suunta)</option>
						</select>
						<button class="danger" id="btnDeleteRoad">Poista</button>
					</div>
					<div class="small">Vinkki: tie snapataan risteyksiksi, kun päitä on lähellä toisiaan.</div>
				</div>

				<div class="card">
					<div class="row">
						<button id="btnSave" class="primary">Save JSON</button>
						<button id="btnLoad">Load JSON</button>
					</div>
					<div class="row">
						<input type="file" id="fileIn" accept="application/json" style="display: none" />
						<button id="btnExportCars">Export tilanne</button>
					</div>
					<div class="small">Save/Load tallentaa kartan + asetukset. Export tilanne lisää myös autot.</div>
				</div>

				<div class="card">
					<div class="kv"><span>Autoja</span><b id="statCars">0</b></div>
					<div class="kv"><span>Teitä</span><b id="statRoads">0</b></div>
					<div class="kv"><span>Risteyksiä</span><b id="statNodes">0</b></div>
					<div class="kv"><span>FPS</span><b id="statFps">—</b></div>
				</div>

				<div class="small">Jos haluat realistisemman reitityksen (lyhin/nopein), tämän rungon päälle voi lisätä Dijkstra/A* graafiin. Mutta jo tämä tuottaa “virtaavaa” liikennettä sadoilla autoilla.</div>
			</div>

			<div id="canvasWrap">
				<canvas id="c"></canvas>
				<div id="hud" class="mono">—</div>
				<div id="help">
					<div><b>Kontrollit</b></div>
					<div class="small">
						<kbd>Space</kbd> + vedä = pan &nbsp;|&nbsp; rulla = zoom<br />
						Piirrä: klikkaa pisteitä, <kbd>Enter</kbd> valmis, <kbd>Esc</kbd> peruuta<br />
						Valitse: klikkaa tietä, vedä pisteitä<br />
						<kbd>Del</kbd> = poista valittu tie &nbsp;|&nbsp; <kbd>P</kbd> = pause/play
					</div>
				</div>
			</div>
		</div>

		<script>
			(() => {
				// =======================
				// Utilities
				// =======================
				const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
				const lerp = (a, b, t) => a + (b - a) * t;
				const now = () => performance.now();
				const rand01 = () => Math.random();

				class Vec2 {
					constructor(x = 0, y = 0) {
						this.x = x;
						this.y = y;
					}
					clone() {
						return new Vec2(this.x, this.y);
					}
					add(v) {
						this.x += v.x;
						this.y += v.y;
						return this;
					}
					sub(v) {
						this.x -= v.x;
						this.y -= v.y;
						return this;
					}
					mul(s) {
						this.x *= s;
						this.y *= s;
						return this;
					}
					len() {
						return Math.hypot(this.x, this.y);
					}
					norm() {
						const l = this.len() || 1;
						this.x /= l;
						this.y /= l;
						return this;
					}
					static add(a, b) {
						return new Vec2(a.x + b.x, a.y + b.y);
					}
					static sub(a, b) {
						return new Vec2(a.x - b.x, a.y - b.y);
					}
					static dot(a, b) {
						return a.x * b.x + a.y * b.y;
					}
					static dist(a, b) {
						return Math.hypot(a.x - b.x, a.y - b.y);
					}
				}

				function distPointToSegment(p, a, b) {
					const ab = Vec2.sub(b, a);
					const ap = Vec2.sub(p, a);
					const ab2 = ab.x * ab.x + ab.y * ab.y;
					let t = ab2 > 0 ? Vec2.dot(ap, ab) / ab2 : 0;
					t = clamp(t, 0, 1);
					const q = new Vec2(a.x + ab.x * t, a.y + ab.y * t);
					return {d: Vec2.dist(p, q), t, q};
				}

				function distPointToPolyline(p, pts) {
					let best = {d: Infinity, seg: -1, t: 0, q: null};
					for (let i = 0; i < pts.length - 1; i++) {
						const r = distPointToSegment(p, pts[i], pts[i + 1]);
						if (r.d < best.d) best = {d: r.d, seg: i, t: r.t, q: r.q};
					}
					return best;
				}

				// =======================
				// Road (polyline)
				// =======================
				let ROAD_ID = 1;

				class Road {
					constructor(points, speedLimit = 14, twoWay = true) {
						this.id = ROAD_ID++;
						this.points = points.map((p) => p.clone());
						this.speedLimit = speedLimit; // m/s
						this.twoWay = !!twoWay;
						this._recompute();
					}
					_recompute() {
						this.segLen = [];
						this.cumLen = [0];
						let sum = 0;
						for (let i = 0; i < this.points.length - 1; i++) {
							const l = Vec2.dist(this.points[i], this.points[i + 1]);
							this.segLen.push(l);
							sum += l;
							this.cumLen.push(sum);
						}
						this.length = sum;
					}
					getStart() {
						return this.points[0];
					}
					getEnd() {
						return this.points[this.points.length - 1];
					}

					// s in [0, length]
					posAt(s) {
						s = clamp(s, 0, this.length);
						// find segment
						let i = 0;
						while (i < this.segLen.length - 1 && this.cumLen[i + 1] < s) i++;
						const segStart = this.points[i],
							segEnd = this.points[i + 1];
						const segS = s - this.cumLen[i];
						const t = this.segLen[i] > 0 ? segS / this.segLen[i] : 0;
						return new Vec2(lerp(segStart.x, segEnd.x, t), lerp(segStart.y, segEnd.y, t));
					}
					dirAt(s) {
						s = clamp(s, 0, this.length);
						let i = 0;
						while (i < this.segLen.length - 1 && this.cumLen[i + 1] < s) i++;
						const a = this.points[i],
							b = this.points[i + 1];
						const d = Vec2.sub(b, a);
						const l = d.len() || 1;
						d.x /= l;
						d.y /= l;
						return d;
					}
				}

				// Directed road "lane" (one direction of a Road)
				class RoadDir {
					constructor(road, forward = true) {
						this.road = road;
						this.forward = forward;
						this.id = `${road.id}:${forward ? 1 : 0}`;
						this.cars = []; // cars currently on this directed road
					}
					length() {
						return this.road.length;
					}
					speedLimit() {
						return this.road.speedLimit;
					}
					startPos() {
						return this.forward ? this.road.getStart() : this.road.getEnd();
					}
					endPos() {
						return this.forward ? this.road.getEnd() : this.road.getStart();
					}
					posAt(s) {
						return this.forward ? this.road.posAt(s) : this.road.posAt(this.road.length - s);
					}
					dirAt(s) {
						const d = this.forward ? this.road.dirAt(s) : this.road.dirAt(this.road.length - s).mul(-1);
						return d;
					}
				}

				// =======================
				// Graph (snap endpoints to nodes)
				// =======================
				class Node {
					constructor(pos) {
						this.pos = pos.clone();
						this.out = []; // RoadDir references
						this.in = [];
						this.id = Node._id++;
					}
				}
				Node._id = 1;

				class Graph {
					constructor(roads, snapDist = 14) {
						this.roads = roads;
						this.snapDist = snapDist;
						this.nodes = [];
						this.roadDirs = new Map(); // id -> RoadDir
						this.startNodeOf = new Map(); // RoadDir.id -> Node
						this.endNodeOf = new Map(); // RoadDir.id -> Node
						this._build();
					}
					_getOrCreateNode(pos) {
						// find existing within snapDist
						for (const n of this.nodes) {
							if (Vec2.dist(n.pos, pos) <= this.snapDist) return n;
						}
						const n = new Node(pos);
						this.nodes.push(n);
						return n;
					}
					_getRoadDir(road, forward) {
						const key = `${road.id}:${forward ? 1 : 0}`;
						if (!this.roadDirs.has(key)) this.roadDirs.set(key, new RoadDir(road, forward));
						return this.roadDirs.get(key);
					}
					_build() {
						Node._id = 1;
						this.nodes = [];
						this.roadDirs.clear();
						this.startNodeOf.clear();
						this.endNodeOf.clear();

						for (const r of this.roads) {
							r._recompute();
							if (r.length < 2) continue;

							const a = r.getStart(),
								b = r.getEnd();
							const na = this._getOrCreateNode(a);
							const nb = this._getOrCreateNode(b);

							// forward dir
							const f = this._getRoadDir(r, true);
							this.startNodeOf.set(f.id, na);
							this.endNodeOf.set(f.id, nb);
							na.out.push(f);
							nb.in.push(f);

							if (r.twoWay) {
								const rev = this._getRoadDir(r, false);
								this.startNodeOf.set(rev.id, nb);
								this.endNodeOf.set(rev.id, na);
								nb.out.push(rev);
								na.in.push(rev);
							}
						}
					}

					// pick next RoadDir at a node, somewhat "keep going straight"
					pickNext(node, incomingDirVec) {
						if (!node || node.out.length === 0) return null;

						// Score by alignment with incoming dir (prefer straight), but allow randomness
						let best = null;
						let bestScore = -Infinity;
						for (const rd of node.out) {
							const d = rd.dirAt(0.01); // direction leaving node
							const align = incomingDirVec ? Vec2.dot(incomingDirVec, d) : 0;
							const score = align + rand01() * 0.35; // tiny noise
							if (score > bestScore) {
								bestScore = score;
								best = rd;
							}
						}
						// Occasionally choose random alternative
						if (node.out.length > 1 && rand01() < 0.15) {
							return node.out[(Math.random() * node.out.length) | 0];
						}
						return best;
					}
				}

				// =======================
				// Cars + IDM-like model
				// =======================
				let CAR_ID = 1;
				class Car {
					constructor(roadDir, s, v = 0) {
						this.id = CAR_ID++;
						this.rd = roadDir;
						this.s = s; // progress along directed road (m)
						this.v = v; // m/s
						this.len = 4.4; // m (visual and spacing)
						this.colorHue = (Math.random() * 360) | 0;
						this.lastNode = null; // for debug
					}
				}

				// =======================
				// World
				// =======================
				const world = {
					roads: [],
					graph: null,
					cars: [],
					params: {
						spawnRatePerMin: 120,
						maxCars: 500,
						v0: 16,
						amax: 1.8,
						bmax: 2.8,
						T: 1.2,
						s0: 2.0,
						delta: 4,
						noise: 0.12,
						snapDist: 14
					},
					running: true,
					timeAcc: 0
				};

				function rebuildGraph() {
					world.graph = new Graph(world.roads, world.params.snapDist);
					// clear per-road car lists
					for (const rd of world.graph.roadDirs.values()) rd.cars.length = 0;
					// reattach cars (drop those that reference removed roads)
					const valid = [];
					for (const c of world.cars) {
						const rd = world.graph.roadDirs.get(c.rd.id);
						if (rd) {
							c.rd = rd;
							valid.push(c);
						}
					}
					world.cars = valid;
				}

				function spawnCar() {
					const g = world.graph;
					if (!g || g.nodes.length === 0) return;
					if (world.cars.length >= world.params.maxCars) return;

					// choose a node that has outgoing edges
					let node = null;
					for (let tries = 0; tries < 20; tries++) {
						const n = g.nodes[(Math.random() * g.nodes.length) | 0];
						if (n.out.length > 0) {
							node = n;
							break;
						}
					}
					if (!node) return;

					const rd = node.out[(Math.random() * node.out.length) | 0];
					// avoid immediate collision by checking first car on that road
					const first = rd.cars.length ? rd.cars[0] : null; // note: rd.cars not sorted yet
					// We'll insert and let IDM handle; but keep s small
					const s = 0.0;
					const v = clamp(world.params.v0 * (0.4 + 0.4 * Math.random()), 0, world.params.v0);
					const car = new Car(rd, s, v);
					world.cars.push(car);
				}

				function idmAccel(v, dv, gap, p) {
					// IDM:
					// a = amax * (1 - (v/v0)^δ - (s*/gap)^2)
					// s* = s0 + v*T + v*dv/(2*sqrt(a*b))
					const v0 = p.v0;
					const a = p.amax;
					const b = p.bmax;
					const delta = p.delta;
					const s0 = p.s0;
					const T = p.T;

					const sqrtab = Math.sqrt(a * b) || 1e-6;
					const sStar = s0 + v * T + (v * dv) / (2 * sqrtab);
					const termFree = 1 - Math.pow(v / Math.max(0.1, v0), delta);
					const termInt = gap > 0 ? Math.pow(sStar / Math.max(0.1, gap), 2) : 10;
					return a * (termFree - termInt);
				}

				function simStep(dt) {
					const g = world.graph;
					if (!g) return;

					// attach cars to their roadDirs
					for (const rd of g.roadDirs.values()) rd.cars.length = 0;
					for (const c of world.cars) {
						c.rd.cars.push(c);
					}

					// sort cars by progress per roadDir
					for (const rd of g.roadDirs.values()) {
						rd.cars.sort((a, b) => a.s - b.s);
					}

					const p = world.params;
					const remove = new Set();

					// update each roadDir's cars with car-following (front-to-back)
					for (const rd of g.roadDirs.values()) {
						const cars = rd.cars;
						if (cars.length === 0) continue;

						for (let i = cars.length - 1; i >= 0; i--) {
							const car = cars[i];
							const lead = i < cars.length - 1 ? cars[i + 1] : null;

							// desired speed: min(global v0, road speedLimit) with noise
							const vLimit = Math.min(p.v0, rd.speedLimit());
							const vDes = vLimit * (1 - p.noise * 0.5 + Math.random() * p.noise);

							let acc = 0;
							if (lead) {
								const gap = lead.s - car.s - lead.len;
								const dv = car.v - lead.v; // approaching positive
								acc = idmAccel(car.v, dv, gap, {...p, v0: vDes});
							} else {
								// free road ahead: accelerate towards vDes
								const termFree = 1 - Math.pow(car.v / Math.max(0.1, vDes), p.delta);
								acc = p.amax * termFree;
							}

							// clamp to plausible braking
							acc = clamp(acc, -p.bmax * 1.4, p.amax * 1.2);

							// integrate
							car.v = clamp(car.v + acc * dt, 0, vLimit * 1.6);
							car.s += car.v * dt;

							// if reached end: hop to next edge
							const L = rd.length();
							if (car.s >= L) {
								const endNode = g.endNodeOf.get(rd.id);
								const incomingDir = rd.dirAt(L - 0.01);
								const next = g.pickNext(endNode, incomingDir);

								if (!next) {
									remove.add(car.id);
								} else {
									car.rd = next;
									car.s = 0.0;
									// slight speed loss on "turn"
									car.v = clamp(car.v * (0.7 + 0.2 * Math.random()), 0, Math.min(p.v0, next.speedLimit()) * 1.2);
								}
							}
						}
					}

					if (remove.size) {
						world.cars = world.cars.filter((c) => !remove.has(c.id));
					}

					// spawning
					const spawnPerSec = p.spawnRatePerMin / 60;
					// probabilistic spawn
					const expected = spawnPerSec * dt;
					if (expected > 1) {
						const n = Math.floor(expected);
						for (let i = 0; i < n; i++) spawnCar();
						if (Math.random() < expected - n) spawnCar();
					} else {
						if (Math.random() < expected) spawnCar();
					}
				}

				// =======================
				// Camera + Input
				// =======================
				const canvas = document.getElementById('c');
				const ctx = canvas.getContext('2d');

				const cam = {
					x: 0,
					y: 0,
					scale: 1.0
				};

				function resize() {
					const r = canvas.getBoundingClientRect();
					canvas.width = Math.max(2, Math.floor(r.width * devicePixelRatio));
					canvas.height = Math.max(2, Math.floor(r.height * devicePixelRatio));
					ctx.setTransform(1, 0, 0, 1, 0, 0);
				}
				window.addEventListener('resize', resize);

				function screenToWorld(mx, my) {
					const r = canvas.getBoundingClientRect();
					const x = (mx - r.left) * devicePixelRatio;
					const y = (my - r.top) * devicePixelRatio;
					const wx = (x - canvas.width * 0.5) / cam.scale + cam.x;
					const wy = (y - canvas.height * 0.5) / cam.scale + cam.y;
					return new Vec2(wx, wy);
				}
				function worldToScreen(p) {
					const x = (p.x - cam.x) * cam.scale + canvas.width * 0.5;
					const y = (p.y - cam.y) * cam.scale + canvas.height * 0.5;
					return new Vec2(x, y);
				}

				let mouse = {down: false, btn: 0, lastX: 0, lastY: 0, space: false};
				let tool = 'select';
				let drawing = null; // array of Vec2 points
				let selectedRoad = null;
				let dragPoint = null; // { road, idx }
				let dragWhole = false;

				const uiTool = document.getElementById('tool');
				const modePill = document.getElementById('modePill');

				function setTool(t) {
					tool = t;
					uiTool.value = t;
					modePill.textContent = t;
					drawing = null;
					dragPoint = null;
					dragWhole = false;
				}
				uiTool.addEventListener('change', () => setTool(uiTool.value));

				window.addEventListener('keydown', (e) => {
					if (e.code === 'Space') mouse.space = true;
					if (e.key === 'p' || e.key === 'P') toggleRun();
					if (e.key === 'Delete' || e.key === 'Backspace') {
						if (selectedRoad) deleteSelectedRoad();
					}
					if (e.key === 'Escape') {
						drawing = null;
					}
					if (e.key === 'Enter') {
						if (tool === 'draw' && drawing && drawing.length >= 2) {
							commitDrawing();
						}
					}
				});
				window.addEventListener('keyup', (e) => {
					if (e.code === 'Space') mouse.space = false;
				});

				canvas.addEventListener(
					'wheel',
					(e) => {
						e.preventDefault();
						const before = screenToWorld(e.clientX, e.clientY);
						const s = Math.exp(-e.deltaY * 0.0012);
						cam.scale = clamp(cam.scale * s, 0.08 * devicePixelRatio, 6.0 * devicePixelRatio);
						const after = screenToWorld(e.clientX, e.clientY);
						cam.x += before.x - after.x;
						cam.y += before.y - after.y;
					},
					{passive: false}
				);

				canvas.addEventListener('mousedown', (e) => {
					mouse.down = true;
					mouse.btn = e.button;
					mouse.lastX = e.clientX;
					mouse.lastY = e.clientY;

					const wantPan = mouse.space || tool === 'pan' || e.button === 1 || e.button === 2;
					if (wantPan) return;

					const w = screenToWorld(e.clientX, e.clientY);

					if (tool === 'draw') {
						if (!drawing) drawing = [];
						drawing.push(w);
						return;
					}

					if (tool === 'select') {
						// point drag if selected and near a point
						if (selectedRoad) {
							const hit = hitTestRoadPoints(w, selectedRoad, 10 / (cam.scale / devicePixelRatio));
							if (hit !== -1) {
								dragPoint = {road: selectedRoad, idx: hit};
								return;
							}
						}

						// select a road
						const r = pickRoad(w);
						if (r) {
							selectedRoad = r;
							syncSelectedUI();
							// allow dragging whole road if shift
							if (e.shiftKey) {
								dragWhole = true;
							}
						} else {
							selectedRoad = null;
							syncSelectedUI();
						}
					}
				});

				canvas.addEventListener('mousemove', (e) => {
					const dx = e.clientX - mouse.lastX;
					const dy = e.clientY - mouse.lastY;
					mouse.lastX = e.clientX;
					mouse.lastY = e.clientY;

					if (!mouse.down) return;

					const wantPan = mouse.space || tool === 'pan' || mouse.btn === 1 || mouse.btn === 2;
					if (wantPan) {
						cam.x -= (dx * devicePixelRatio) / cam.scale;
						cam.y -= (dy * devicePixelRatio) / cam.scale;
						return;
					}

					const w = screenToWorld(e.clientX, e.clientY);

					if (dragPoint) {
						const rd = dragPoint.road;
						rd.points[dragPoint.idx].x = w.x;
						rd.points[dragPoint.idx].y = w.y;
						rd._recompute();
						rebuildGraph();
						return;
					}
					if (dragWhole && selectedRoad) {
						// move all points by delta in world coords
						const dWorld = new Vec2(-(dx * devicePixelRatio) / cam.scale, -(dy * devicePixelRatio) / cam.scale).mul(-1);
						for (const p of selectedRoad.points) {
							p.x += dWorld.x;
							p.y += dWorld.y;
						}
						selectedRoad._recompute();
						rebuildGraph();
					}
				});

				canvas.addEventListener('mouseup', () => {
					mouse.down = false;
					dragPoint = null;
					dragWhole = false;
				});
				canvas.addEventListener('mouseleave', () => {
					mouse.down = false;
					dragPoint = null;
					dragWhole = false;
				});

				canvas.addEventListener('dblclick', (e) => {
					if (tool === 'draw' && drawing && drawing.length >= 2) {
						commitDrawing();
					}
				});

				function hitTestRoadPoints(w, road, radiusWorld) {
					let best = -1;
					let bestD = Infinity;
					for (let i = 0; i < road.points.length; i++) {
						const d = Vec2.dist(w, road.points[i]);
						if (d < radiusWorld && d < bestD) {
							bestD = d;
							best = i;
						}
					}
					return best;
				}

				function pickRoad(w) {
					// choose closest road within threshold
					const thr = 12 / (cam.scale / devicePixelRatio); // px to world
					let best = null;
					let bestD = Infinity;
					for (const r of world.roads) {
						const info = distPointToPolyline(w, r.points);
						if (info.d < thr && info.d < bestD) {
							bestD = info.d;
							best = r;
						}
					}
					return best;
				}

				function commitDrawing() {
					// simplify: remove near-duplicates
					const pts = [];
					for (const p of drawing) {
						if (pts.length === 0 || Vec2.dist(pts[pts.length - 1], p) > 2) pts.push(p.clone());
					}
					drawing = null;

					if (pts.length < 2) return;
					const r = new Road(pts, Number(document.getElementById('roadSpeed').value) || 14, true);
					world.roads.push(r);
					selectedRoad = r;
					rebuildGraph();
					syncSelectedUI();
				}

				// =======================
				// Rendering
				// =======================
				function draw() {
					ctx.setTransform(1, 0, 0, 1, 0, 0);
					ctx.clearRect(0, 0, canvas.width, canvas.height);

					// background grid
					drawGrid();

					// roads
					for (const r of world.roads) {
						drawRoad(r, r === selectedRoad);
					}

					// drawing preview
					if (drawing && drawing.length) {
						drawPolyline(drawing, 'rgba(180,220,255,0.9)', 2.5);
						// preview from last point to cursor (optional)
					}

					// nodes
					if (world.graph) {
						drawNodes(world.graph.nodes);
					}

					// cars
					drawCars();

					// HUD
					updateHUD();
				}

				function drawGrid() {
					const step = 50; // world meters-ish
					const leftTop = screenToWorld(0, 0);
					const rightBottom = screenToWorld(canvas.getBoundingClientRect().left + canvas.width / devicePixelRatio, canvas.getBoundingClientRect().top + canvas.height / devicePixelRatio);

					const minX = Math.floor((leftTop.x - 2000) / step) * step;
					const maxX = Math.ceil((rightBottom.x + 2000) / step) * step;
					const minY = Math.floor((leftTop.y - 2000) / step) * step;
					const maxY = Math.ceil((rightBottom.y + 2000) / step) * step;

					ctx.save();
					ctx.lineWidth = 1;
					ctx.strokeStyle = 'rgba(255,255,255,0.04)';
					for (let x = minX; x <= maxX; x += step) {
						const a = worldToScreen(new Vec2(x, minY));
						const b = worldToScreen(new Vec2(x, maxY));
						ctx.beginPath();
						ctx.moveTo(a.x, a.y);
						ctx.lineTo(b.x, b.y);
						ctx.stroke();
					}
					for (let y = minY; y <= maxY; y += step) {
						const a = worldToScreen(new Vec2(minX, y));
						const b = worldToScreen(new Vec2(maxX, y));
						ctx.beginPath();
						ctx.moveTo(a.x, a.y);
						ctx.lineTo(b.x, b.y);
						ctx.stroke();
					}
					ctx.restore();
				}

				function drawPolyline(pts, strokeStyle, width) {
					ctx.save();
					ctx.strokeStyle = strokeStyle;
					ctx.lineWidth = width * devicePixelRatio;
					ctx.lineCap = 'round';
					ctx.lineJoin = 'round';
					ctx.beginPath();
					for (let i = 0; i < pts.length; i++) {
						const s = worldToScreen(pts[i]);
						if (i === 0) ctx.moveTo(s.x, s.y);
						else ctx.lineTo(s.x, s.y);
					}
					ctx.stroke();
					ctx.restore();
				}

				function drawRoad(r, selected) {
					// base
					drawPolyline(r.points, selected ? 'rgba(120,200,255,0.95)' : 'rgba(200,220,255,0.35)', selected ? 3.5 : 2.5);

					// direction arrow (if one-way)
					if (!r.twoWay) {
						const midS = r.length * 0.5;
						const p = r.posAt(midS);
						const d = r.dirAt(midS);
						const p2 = Vec2.add(p, d.clone().mul(14));
						drawArrow(p, p2, 'rgba(240,190,120,0.85)');
					}

					// selected points
					if (selected) {
						ctx.save();
						for (const pt of r.points) {
							const s = worldToScreen(pt);
							ctx.fillStyle = 'rgba(120,200,255,0.95)';
							ctx.beginPath();
							ctx.arc(s.x, s.y, 4.0 * devicePixelRatio, 0, Math.PI * 2);
							ctx.fill();
							ctx.strokeStyle = 'rgba(10,14,18,0.75)';
							ctx.lineWidth = 2.0 * devicePixelRatio;
							ctx.stroke();
						}
						ctx.restore();
					}
				}

				function drawArrow(aW, bW, color) {
					const a = worldToScreen(aW);
					const b = worldToScreen(bW);
					const dx = b.x - a.x,
						dy = b.y - a.y;
					const L = Math.hypot(dx, dy) || 1;
					const ux = dx / L,
						uy = dy / L;
					const head = 8 * devicePixelRatio;
					const wing = 5 * devicePixelRatio;
					ctx.save();
					ctx.strokeStyle = color;
					ctx.lineWidth = 2.0 * devicePixelRatio;
					ctx.lineCap = 'round';
					ctx.beginPath();
					ctx.moveTo(a.x, a.y);
					ctx.lineTo(b.x, b.y);
					ctx.stroke();
					ctx.beginPath();
					ctx.moveTo(b.x, b.y);
					ctx.lineTo(b.x - ux * head + -uy * wing, b.y - uy * head + ux * wing);
					ctx.lineTo(b.x - ux * head + uy * wing, b.y - uy * head + -ux * wing);
					ctx.closePath();
					ctx.fillStyle = color;
					ctx.fill();
					ctx.restore();
				}

				function drawNodes(nodes) {
					ctx.save();
					for (const n of nodes) {
						const s = worldToScreen(n.pos);
						ctx.fillStyle = 'rgba(255,255,255,0.18)';
						ctx.beginPath();
						ctx.arc(s.x, s.y, 3.0 * devicePixelRatio, 0, Math.PI * 2);
						ctx.fill();
					}
					ctx.restore();
				}

				function drawCars() {
					ctx.save();
					for (const car of world.cars) {
						const p = car.rd.posAt(car.s);
						const d = car.rd.dirAt(car.s);
						const s = worldToScreen(p);

						// car rectangle oriented by direction
						const angle = Math.atan2(d.y, d.x);
						const L = 8 * devicePixelRatio; // visual length
						const W = 4.5 * devicePixelRatio; // visual width
						ctx.translate(s.x, s.y);
						ctx.rotate(angle);
						ctx.fillStyle = `hsla(${car.colorHue}, 80%, 62%, 0.95)`;
						roundRect(-L * 0.5, -W * 0.5, L, W, 2.2 * devicePixelRatio);
						ctx.fill();

						// windshield
						ctx.fillStyle = 'rgba(10,14,18,0.55)';
						roundRect(0.0, -W * 0.35, L * 0.38, W * 0.7, 1.6 * devicePixelRatio);
						ctx.fill();

						ctx.setTransform(1, 0, 0, 1, 0, 0);
					}
					ctx.restore();
				}

				function roundRect(x, y, w, h, r) {
					r = Math.min(r, w * 0.5, h * 0.5);
					ctx.beginPath();
					ctx.moveTo(x + r, y);
					ctx.arcTo(x + w, y, x + w, y + h, r);
					ctx.arcTo(x + w, y + h, x, y + h, r);
					ctx.arcTo(x, y + h, x, y, r);
					ctx.arcTo(x, y, x + w, y, r);
					ctx.closePath();
				}

				// =======================
				// UI wiring
				// =======================
				const el = (id) => document.getElementById(id);

				function bindRange(rangeId, numberId, setter) {
					const r = el(rangeId),
						n = el(numberId);
					const sync = (v) => {
						r.value = v;
						n.value = v;
						setter(Number(v));
					};
					r.addEventListener('input', () => sync(r.value));
					n.addEventListener('change', () => sync(n.value));
					sync(r.value);
				}

				bindRange('spawnRate', 'spawnRateN', (v) => (world.params.spawnRatePerMin = v));
				bindRange('maxCars', 'maxCarsN', (v) => (world.params.maxCars = v | 0));
				bindRange('v0', 'v0N', (v) => (world.params.v0 = v));
				bindRange('amax', 'amaxN', (v) => (world.params.amax = v));
				bindRange('bmax', 'bmaxN', (v) => (world.params.bmax = v));
				bindRange('T', 'TN', (v) => (world.params.T = v));
				bindRange('s0', 's0N', (v) => (world.params.s0 = v));
				bindRange('delta', 'deltaN', (v) => (world.params.delta = v | 0));
				bindRange('noise', 'noiseN', (v) => (world.params.noise = v));

				el('btnPlay').addEventListener('click', toggleRun);
				el('btnStep').addEventListener('click', () => {
					world.running = false;
					el('btnPlay').textContent = '⏸ Pysäytetty';
					simStep(1 / 60);
				});

				el('btnClearCars').addEventListener('click', () => {
					world.cars = [];
				});
				el('btnClearMap').addEventListener('click', () => {
					world.roads = [];
					world.cars = [];
					selectedRoad = null;
					rebuildGraph();
					syncSelectedUI();
				});

				el('btnApplyRoad').addEventListener('click', () => {
					if (!selectedRoad) return;
					const sp = Number(el('roadSpeed').value) || selectedRoad.speedLimit;
					selectedRoad.speedLimit = clamp(sp, 1, 120);
					selectedRoad.twoWay = el('roadTwoWay').value === 'true';
					rebuildGraph();
				});

				function deleteSelectedRoad() {
					if (!selectedRoad) return;
					const id = selectedRoad.id;
					world.roads = world.roads.filter((r) => r.id !== id);
					selectedRoad = null;
					rebuildGraph();
					syncSelectedUI();
				}
				el('btnDeleteRoad').addEventListener('click', deleteSelectedRoad);

				function syncSelectedUI() {
					if (!selectedRoad) {
						el('selInfo').textContent = '—';
						return;
					}
					el('selInfo').textContent = `road#${selectedRoad.id}`;
					el('roadSpeed').value = String(selectedRoad.speedLimit);
					el('roadTwoWay').value = String(!!selectedRoad.twoWay);
				}

				function toggleRun() {
					world.running = !world.running;
					el('btnPlay').textContent = world.running ? '▶ Käynnissä' : '⏸ Pysäytetty';
				}

				// Save/Load
				function downloadJSON(obj, name) {
					const data = JSON.stringify(obj, null, 2);
					const blob = new Blob([data], {type: 'application/json'});
					const url = URL.createObjectURL(blob);
					const a = document.createElement('a');
					a.href = url;
					a.download = name;
					document.body.appendChild(a);
					a.click();
					a.remove();
					URL.revokeObjectURL(url);
				}

				el('btnSave').addEventListener('click', () => {
					const payload = {
						version: 1,
						params: world.params,
						roads: world.roads.map((r) => ({
							id: r.id,
							speedLimit: r.speedLimit,
							twoWay: r.twoWay,
							points: r.points.map((p) => [p.x, p.y])
						}))
					};
					downloadJSON(payload, 'traffic_map.json');
				});

				el('btnExportCars').addEventListener('click', () => {
					const payload = {
						version: 1,
						params: world.params,
						roads: world.roads.map((r) => ({
							id: r.id,
							speedLimit: r.speedLimit,
							twoWay: r.twoWay,
							points: r.points.map((p) => [p.x, p.y])
						})),
						cars: world.cars.map((c) => ({
							id: c.id,
							rd: c.rd.id,
							s: c.s,
							v: c.v,
							hue: c.colorHue
						}))
					};
					downloadJSON(payload, 'traffic_state.json');
				});

				el('btnLoad').addEventListener('click', () => el('fileIn').click());
				el('fileIn').addEventListener('change', async (e) => {
					const file = e.target.files?.[0];
					if (!file) return;
					const text = await file.text();
					try {
						const obj = JSON.parse(text);
						loadFrom(obj);
					} catch (err) {
						alert('JSON parse error: ' + err);
					} finally {
						e.target.value = '';
					}
				});

				function loadFrom(obj) {
					// reset
					world.roads = [];
					world.cars = [];
					selectedRoad = null;

					if (obj.params) {
						// keep unknown keys but overwrite known
						world.params = {...world.params, ...obj.params};
						// sync UI inputs
						el('spawnRate').value = el('spawnRateN').value = world.params.spawnRatePerMin;
						el('maxCars').value = el('maxCarsN').value = world.params.maxCars;
						el('v0').value = el('v0N').value = world.params.v0;
						el('amax').value = el('amaxN').value = world.params.amax;
						el('bmax').value = el('bmaxN').value = world.params.bmax;
						el('T').value = el('TN').value = world.params.T;
						el('s0').value = el('s0N').value = world.params.s0;
						el('delta').value = el('deltaN').value = world.params.delta;
						el('noise').value = el('noiseN').value = world.params.noise;
					}

					ROAD_ID = 1;
					if (Array.isArray(obj.roads)) {
						// Preserve ids by setting ROAD_ID after reading
						let maxId = 0;
						for (const rr of obj.roads) {
							const pts = (rr.points || []).map((a) => new Vec2(a[0], a[1]));
							if (pts.length < 2) continue;
							const r = new Road(pts, rr.speedLimit ?? 14, rr.twoWay ?? true);
							if (typeof rr.id === 'number') {
								r.id = rr.id;
								maxId = Math.max(maxId, rr.id);
							}
							world.roads.push(r);
						}
						ROAD_ID = Math.max(ROAD_ID, maxId + 1);
					}

					rebuildGraph();

					if (Array.isArray(obj.cars) && world.graph) {
						// Recreate cars if file included them
						for (const cc of obj.cars) {
							const rd = world.graph.roadDirs.get(cc.rd);
							if (!rd) continue;
							const car = new Car(rd, cc.s ?? 0, cc.v ?? 0);
							if (typeof cc.id === 'number') car.id = cc.id;
							if (typeof cc.hue === 'number') car.colorHue = cc.hue;
							world.cars.push(car);
						}
						if (obj.cars.length) {
							CAR_ID = Math.max(CAR_ID, Math.max(...obj.cars.map((c) => c.id || 0)) + 1);
						}
					}

					// center camera to content
					fitCameraToRoads();
					syncSelectedUI();
				}

				function fitCameraToRoads() {
					if (world.roads.length === 0) {
						cam.x = 0;
						cam.y = 0;
						cam.scale = 1.0 * devicePixelRatio;
						return;
					}
					let minX = Infinity,
						minY = Infinity,
						maxX = -Infinity,
						maxY = -Infinity;
					for (const r of world.roads) {
						for (const p of r.points) {
							minX = Math.min(minX, p.x);
							minY = Math.min(minY, p.y);
							maxX = Math.max(maxX, p.x);
							maxY = Math.max(maxY, p.y);
						}
					}
					cam.x = (minX + maxX) / 2;
					cam.y = (minY + maxY) / 2;
					const w = Math.max(100, maxX - minX);
					const h = Math.max(100, maxY - minY);
					const scaleX = canvas.width / (w * 1.3);
					const scaleY = canvas.height / (h * 1.3);
					cam.scale = clamp(Math.min(scaleX, scaleY), 0.12 * devicePixelRatio, 3.0 * devicePixelRatio);
				}

				// =======================
				// HUD & stats
				// =======================
				const hud = el('hud');
				const statCars = el('statCars');
				const statRoads = el('statRoads');
				const statNodes = el('statNodes');
				const statFps = el('statFps');

				function updateHUD() {
					const g = world.graph;
					statCars.textContent = String(world.cars.length);
					statRoads.textContent = String(world.roads.length);
					statNodes.textContent = String(g ? g.nodes.length : 0);

					const p = world.params;
					hud.textContent = `tool=${tool} | cars=${world.cars.length}/${p.maxCars} | spawn=${p.spawnRatePerMin.toFixed(0)}/min | ` + `zoom=${(cam.scale / devicePixelRatio).toFixed(2)}x`;
				}

				// =======================
				// Main loop (fixed timestep)
				// =======================
				resize();
				cam.scale = 1.0 * devicePixelRatio;

				// start with a tiny demo map
				world.roads.push(new Road([new Vec2(-220, -50), new Vec2(220, -50)], 16, true));
				world.roads.push(new Road([new Vec2(-220, 50), new Vec2(220, 50)], 16, true));
				world.roads.push(new Road([new Vec2(0, -200), new Vec2(0, 200)], 14, true));
				rebuildGraph();
				fitCameraToRoads();

				let lastT = now();
				let fpsAcc = 0,
					fpsCount = 0,
					fpsLast = now();

				function frame() {
					const t = now();
					const dtReal = clamp((t - lastT) / 1000, 0, 0.05);
					lastT = t;

					// fixed step
					const dt = 1 / 60;
					if (world.running) {
						world.timeAcc += dtReal;
						const maxSteps = 5;
						let steps = 0;
						while (world.timeAcc >= dt && steps < maxSteps) {
							simStep(dt);
							world.timeAcc -= dt;
							steps++;
						}
					}

					draw();

					// fps
					fpsAcc += 1;
					fpsCount++;
					if (t - fpsLast > 500) {
						const fps = fpsCount / ((t - fpsLast) / 1000);
						statFps.textContent = fps.toFixed(0);
						fpsLast = t;
						fpsCount = 0;
					}

					requestAnimationFrame(frame);
				}
				requestAnimationFrame(frame);

				// default tool
				setTool('select');
			})();
		</script>
	</body>
</html>
